/**
 * 
 */
package com.graphql_java_generator.plugin.conf;

import java.io.File;

import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * This class contains all parameters for the <I>generateServerCode</I> goal/task.
 * 
 * @author etienne-sf
 */
public interface GenerateServerCodeConfiguration extends GenerateCodeCommonConfiguration {
	/**
	 * The packaging is the kind of artefact generated by the project. Typically: jar (for a standard Java application)
	 * or war (for a webapp)
	 */
	public Packaging getPackaging();

	/**
	 * <P>
	 * (only for server mode) A comma separated list of package names, <B>without</B> double quotes, that will also be
	 * parsed by Spring, to discover Spring beans, Spring repositories and JPA entities when the server starts. You
	 * should use this parameter only for packages that are not subpackage of the package defined in the _packageName_
	 * parameter and not subpackage of <I>com.graphql_java_generator</I>
	 * </P>
	 * <P>
	 * This allows for instance, to set <I>packageName</I> to <I>your.app.package.graphql</I>, and to define your Spring
	 * beans, like the
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/server.html">DataFetcherDelegates</A> or
	 * your Spring data repositories in any other folder, by setting for instance scanBasePackages to
	 * <I>your.app.package.impl, your.app.package.graphql</I>, or just <I>your.app.package</I>
	 * </P>
	 */
	public String getScanBasePackages();

	/**
	 * Transform the list of package names returned by {@link #getScanBasePackages()} by a list of package names,
	 * surrounded by double quotes, as it can be used in the Spring scanBasePackages property of the
	 * {@link SpringBootApplication} Spring annotation.
	 * 
	 * @return A string that can be added to the scanBasePackages property of {@link SpringBootApplication}, that is: an
	 *         empty String, or a list of quoted package names starting with a comma (e.g.: ", \"my.package\",
	 *         \"my.other.package\"")
	 */
	public default String getQuotedScanBasePackages() {
		String scanBasePackages = getScanBasePackages();

		if (scanBasePackages == null || scanBasePackages.contentEquals("") || scanBasePackages.contentEquals("null")) {
			return "";
		}

		// Let's remove all spaces. It will be easier to insert the good double quotes, afterwards.
		// Let's say scanBasePackages is: a, b, c,d
		scanBasePackages = scanBasePackages.replace(" ", "");// scanBasePackages is now a,b,c,d
		scanBasePackages = scanBasePackages.replace(",", "\",\"");// scanBasePackages is now a","b","c","d
		scanBasePackages = ",\"" + scanBasePackages + "\"";// scanBasePackages is now ,"a","b","c","d"
		return scanBasePackages;
	}

	/**
	 * <P>
	 * schemaPersonalizationFile is the file name where the GraphQL maven plugin will find personalization that it must
	 * apply before generating the code. This applies to the <B>server</B> mode only. See
	 * <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/schema_personalization.html">the doc on
	 * the plugin web site</A> for more details.
	 * </P>
	 * <P>
	 * The standard file would be something like /src/main/graphql/schemaPersonalizationFile.json, which avoids to embed
	 * this compile time file within your maven artifact (as it is not in the /src/main/java nor in the
	 * /src/main/resources folders).
	 * </P>
	 * 
	 * @return
	 */
	public File getSchemaPersonalizationFile();

	/**
	 * <P>
	 * <I>Since 1.7.1 version</I>
	 * </P>
	 * <P>
	 * Generates a XxxxResponse class for each query/mutation/subscription, and (if separateUtilityClasses is true) Xxxx
	 * classes in the util subpackage. This allows to keep compatibility with code Developed with the 1.x versions of
	 * the plugin.
	 * </P>
	 * <P>
	 * The best way to use the plugin is to directly use the Xxxx query/mutation/subscription classes, where Xxxx is the
	 * query/mutation/subscription name defined in the GraphQL schema.
	 * </P>
	 */
	public boolean isGenerateDeprecatedRequestResponse();

	/**
	 * <P>
	 * Indicates whether the plugin should generate the JPA annotations, for generated objects, when in server mode.
	 * </P>
	 * <P>
	 * <B><I>Default value is false</I></B>
	 * </P>
	 */
	public boolean isGenerateJPAAnnotation();

	/**
	 * <P>
	 * Indicates whether the utility classes (that is: the classes that are not match an item in the GraphQL schema) are
	 * generated in the same package than the classes that matches the GraphQL schema.
	 * </P>
	 * <P>
	 * That is: internal technical classes, java classes that contain the method to execute the
	 * queries/mutations/subscriptions, Jackson deserializer for custom scalars...
	 * </P>
	 * <P>
	 * The default value is false, to maintain the previous behavior. In this case, all classes are generated in the
	 * <I>packageName</I>, or the default package if this parameter is not defined.
	 * </P>
	 * <P>
	 * If true, the GraphQL classes are generated in the package defined in the <I>packageName</I> plugin parameter. And
	 * all the utility classes are generated in the <I>util</I> subpackage of this package.
	 * </P>
	 * 
	 * @return
	 */
	public boolean isSeparateUtilityClasses();

	/** Logs all the configuration parameters (only when in the debug level) */
	@Override
	public default void logConfiguration() {
		if (getLog().isDebugEnabled()) {
			getLog().debug("-- start configuration --");
			getLog().debug(
					"The graphql-java-generator Plugin Configuration for the generateServerCode goal/task is -->");
			logGenerateServerCodeConfiguration();
			getLog().debug("-- end configuration --");
		}
	}

	/**
	 * Logs all the configuration parameters for the <I>generateServerCode</I> task/goal (only when in the debug level)
	 */
	public default void logGenerateServerCodeConfiguration() {
		getLog().debug("  Parameters specific to the generateServerCode task/goal:");
		getLog().debug("    generateDeprecatedRequestResponse: " + isGenerateDeprecatedRequestResponse());
		getLog().debug("    generateJPAAnnotation: " + isGenerateJPAAnnotation());
		getLog().debug("    packaging: " + getPackaging());
		getLog().debug("    scanBasePackages: " + getScanBasePackages());
		getLog().debug("    separateUtilityClasses: " + isSeparateUtilityClasses());
		getLog().debug("    schemaPersonalizationFile: " + getSchemaPersonalizationFile());
		logGenerateCodeCommonConfiguration();
	}
}

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.8.1 from src\site\apt/client.apt.vm at 2020-03-13 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>GraphQL Java Generator - Maven Plugin &#x2013; GraphQL Maven Plugin (client mode)</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
    
  </head>
  <body class="composite">
    <div id="banner">
<div id="bannerLeft">
com.graphql-java-generator:graphql-maven-plugin-project
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="projectVersion">Version: 1.5.0</span>
      </div>
      <div class="xright"><a href="project.html" title="Project on Github">Project on Github</a>        &nbsp;| <span id="publishDate">Last Published: 2020-03-13</span>
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
       <h5>Maven Plugin Usage</h5>
    <ul>
     <li class="none"><a href="index.html" title="Introduction">Introduction</a></li>
     <li class="none"><a href="customscalars.html" title="Custom Scalars">Custom Scalars</a></li>
    </ul>
       <h5>Client mode</h5>
    <ul>
     <li class="none"><strong>Plugin usage</strong></li>
     <li class="none"><a href="introspection.html" title="Introspection">Introspection</a></li>
    </ul>
       <h5>Server mode</h5>
    <ul>
     <li class="none"><a href="server.html" title="Plugin usage">Plugin usage</a></li>
     <li class="none"><a href="schema_personalization.html" title="Howto personalize the generated code">Howto personalize the generated code</a></li>
    </ul>
       <h5>Project usage</h5>
    <ul>
     <li class="none"><a href="howto_build.html" title="How to build?">How to build?</a></li>
     <li class="none"><a href="howto_contribute.html" title="How to contribute?">How to contribute?</a></li>
     <li class="none"><a href="howto_publish_site.html" title="How to publish the site?">How to publish the site?</a></li>
    </ul>
       <h5>Modules</h5>
    <ul>
     <li class="none"><a href="graphql-java-runtime/index.html" title="graphql-java-runtime">graphql-java-runtime</a></li>
     <li class="none"><a href="graphql-maven-plugin/index.html" title="graphql-maven-plugin">graphql-maven-plugin</a></li>
     <li class="none"><a href="graphql-java-client-dependencies/index.html" title="graphql-java-client-dependencies">graphql-java-client-dependencies</a></li>
     <li class="none"><a href="graphql-java-server-dependencies/index.html" title="graphql-java-server-dependencies">graphql-java-server-dependencies</a></li>
     <li class="none"><a href="graphql-maven-plugin-logic/index.html" title="graphql-maven-plugin-logic">graphql-maven-plugin-logic</a></li>
     <li class="none"><a href="graphql-maven-plugin-samples/index.html" title="graphql-maven-plugin-samples">graphql-maven-plugin-samples</a></li>
    </ul>
       <h5>Project Documentation</h5>
    <ul>
     <li class="collapsed"><a href="project-info.html" title="Project Information">Project Information</a></li>
    </ul>
      <a href="https://maven.apache.org/" title="Maven" class="poweredBy">
        <img class="poweredBy"  alt="Maven" src="https://maven.apache.org/images/logos/maven-feather.png"     />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<div class="section">
<h2><a name="Client_mode_usage_description"></a>Client mode usage description</h2>
<ul>
<li><a href="#Client_mode_usage_description">Client mode usage description</a>
<ul>
<li><a href="#Summary">Summary</a></li>
<li><a href="#Presentation">Presentation</a></li>
<li><a href="#How_to_use_the_plugin.3F">How to use the plugin?</a></li>
<li><a href="#Full_queries_versus_Partial_queries">Full queries versus Partial queries</a>
<ul>
<li><a href="#Full_queries.2Fmutations.2Fsubscriptions">Full queries/mutations/subscriptions</a></li>
<li><a href="#Partial_queries.2Fmutations.2Fsubscriptions">Partial queries/mutations/subscriptions</a></li></ul></li>
<li><a href="#How_to_execute_a_GraphQL_query.3F">How to execute a GraphQL query?</a></li>
<li><a href="#GraphQL_query_.28and_mutation.29_calls">GraphQL query (and mutation) calls</a>
<ul>
<li><a href="#Direct_Query_.28or_Mutation.29_call">Direct Query (or Mutation) call</a></li>
<li><a href="#Prepared_Query_.28or_Mutation.29_call">Prepared Query (or Mutation) call</a></li></ul></li>
<li><a href="#Prepare_your_GraphQL_queries">Prepare your GraphQL queries</a></li>
<li><a href="#Create_an_ObjectResponse_with_a_query_string">Create an ObjectResponse with a query string</a></li>
<li><a href="#Create_an_ObjectResponse_with_an_ObjectResponse_Builder">Create an ObjectResponse with an ObjectResponse Builder</a></li>
<li><a href="#How_to_manager_input_parameters">How to manager input parameters</a>
<ul>
<li><a href="#How_to_use_Query.2FMutation.2FSubscription_input_parameters">How to use Query/Mutation/Subscription input parameters</a></li>
<li><a href="#How_to_use_Field_input_parameters.2C_for_standard_GraphQL_Types">How to use Field input parameters, for standard GraphQL Types</a></li></ul></li>
<li><a href="#Use_a_Spring_Bean">Use a Spring Bean</a></li></ul></li></ul>
<div class="section">
<h3><a name="Summary">Summary</a></h3>
<p>The client mode makes it easy for a Java GraphQL client-side application, to execute queries/mutations/subscriptions against a GraphQL server. The graphql-maven-plugin generates all the necessary code, so that a Java application can call a GraphQL server by simply calling the relevant Java method.</p></div>
<div class="section">
<h3><a name="Presentation">Presentation</a></h3>
<p>When configuring the graphql-maven-plugin in client mode, it reads a graphqls schema file, and generates all the necessary code to make it easy to call a GraphQL server. </p>
<p>As an overview, it generates:</p>
<ul>
<li>One java class for the Query object. This object contains all the method allowing to execute a full query, and shortcuts methods to execute each of the queries defined in the query object.</li>
<li>One java class for the Mutation object (if any). It's the same as for the Query object (described just above)</li>
<li>One POJO for each standard object of the GraphQL object</li>
<li>All the necessary runtime is actually attached as source code into your project: the generated code is stand-alone. So, your project, when it runs, doesn't depend on any external dependency from graphql-java-generator. <b>This is why we call it an accelerator</b>: you can generate the code once, and get rid of graphql-java-generator if you wish. BTW: we think its better to continue using it! But you're free to leave, and keep the generated code. :)</li></ul></div>
<div class="section">
<h3><a name="How_to_use_the_plugin.3F"></a><a name="How_to_use_the_plugin">How to use the plugin?</a></h3>
<p>First, you'll have to create or get your GraphQL schema. The GraphQL plugin expects a <i>.graphqls</i> file. See the <a class="externalLink" href="https://graphql.org/learn/schema/">GraphQL schema doc</a> for all the details.</p>
<p>Then, add the plugin to your Maven POM file:</p>
<div class="source">
<pre>&lt;project ...&gt;
...

        &lt;build&gt;
                &lt;plugins&gt;
...
                        &lt;plugin&gt;
                                &lt;groupId&gt;com.graphql-java-generator&lt;/groupId&gt;
                                &lt;artifactId&gt;graphql-maven-plugin&lt;/artifactId&gt;
                                &lt;version&gt;1.5.0&lt;/version&gt;
                                &lt;executions&gt;
                                        &lt;execution&gt;
                                                &lt;goals&gt;
                                                        &lt;goal&gt;graphql&lt;/goal&gt;
                                                &lt;/goals&gt;
                                        &lt;/execution&gt;
                                &lt;/executions&gt;
                                &lt;configuration&gt;
                                        &lt;mode&gt;client&lt;/mode&gt;
                                        &lt;packageName&gt;my.target.package&lt;/packageName&gt;
                                &lt;/configuration&gt;
                        &lt;/plugin&gt;
...
                        &lt;extensions&gt;
                                &lt;!-- Adding these extensions prevents the error below, with JDK 9 and higher: --&gt;
                                &lt;!-- NoSuchMethodError: 'java.lang.String javax.annotation.Resource.lookup()' --&gt;
                                &lt;extension&gt;
                                        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
                                        &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;
                                        &lt;version&gt;1.3.2&lt;/version&gt;
                                &lt;/extension&gt;
                                &lt;extension&gt;
                                        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
                                        &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt;
                                        &lt;version&gt;1.0&lt;/version&gt;
                                &lt;/extension&gt;
                        &lt;/extensions&gt;
        
                &lt;/plugins&gt;
        &lt;/build&gt;
...
&lt;/project&gt;
</pre></div>
<p>The mode is optional, here, as client is the default one. Valid values are: <i>client</i> and <i>server</i>.</p>
<p>You can define the package that will contain the generated code. If you don't, the default package is <i>com.generated.graphql</i>. This package contains the generated code. </p>
<p>The necessary runtime code source is joined into the generated code, and remains in its original package, which is <i>com.graphql_java_generator.*</i>. So everything is embedded.</p></div>
<div class="section">
<h3><a name="Full_queries_versus_Partial_queries">Full queries versus Partial queries</a></h3>
<p>When the plugin generates the query/mutation/subscription java classes, it generates two families of methods:</p>
<div class="section">
<h4><a name="Full_queries.2Fmutations.2Fsubscriptions"></a><a name="Full_queriesmutationssubscriptions">Full queries/mutations/subscriptions</a></h4>
<p>The <i>exec</i> and <i>execWithBindValues</i> methods allows to execute full GraphQL queries, that is: the GraphQL request, without the query/mutation/subscription keyword (see below for sample).</p>
<p>The <i>getResponseBuilder()</i> method returns a Builder that allows you to prepare the GraphQL request during the application initialization. This will accelerate the further GraphQL calls for this query/mutation/subscription. And it allows to check at startup time that your queries/mutations/subscriptions are valid.</p>
<p>If you want/need to specify a GraphQL directive on the query/mutation/subscription itself, you must use a full query. For instance:</p>
<div class="source">
<pre>HumanInput input = new HumanInput();
..
[putting some content into input]
..
MyQueryTypeResponse resp = queryType.exec(
                &quot;{createHuman (human: &amp;humanInput)  @myDirective(value:&amp;value, anotherValue: ?anotherValueParam) {id name appearsIn friends {id name}}}&quot;,
                &quot;value&quot;, &quot;the value&quot;, &quot;humanInput&quot;, input);
Human human = resp.getCreateHuman();
</pre></div>
<p>The full queries allows you to execute several queries, or several mutations, or several subscriptions in one server call. Please note that you can not mix queries and mutations in the same call. And, as the plugin currently doesn't manage aliases on the query/mutation/subscription level, you can not execute several times the same query/mutation/subscription in the same call. </p>
<p>For instance, this is one of the integration tests in the allGraphQLCases client project:</p>
<div class="source">
<pre>MyQueryTypeResponse resp = queryType.exec(
                &quot;{&quot;//
                        + &quot; directiveOnQuery (uppercase: false) @testDirective(value:&amp;value, anotherValue:?anotherValue)&quot;//
                        + &quot; withOneOptionalParam {id name appearsIn friends {id name}}&quot;//
                        + &quot; withoutParameters {appearsIn @skip(if: &amp;skipAppearsIn) name @skip(if: &amp;skipName) }&quot;//
                        + &quot;}&quot;,
                &quot;value&quot;, &quot;An expected returned string&quot;, //
                &quot;skipAppearsIn&quot;, true, //
                &quot;skipName&quot;, false);
List&lt;String&gt; directiveOnQuery = resp.getDirectiveOnQuery();
Character withOneOptionalParam = resp.getWithOneOptionalParam();
List&lt;Character&gt; withoutParameters = resp.getWithoutParameters();
</pre></div>
<p>In this sample, you can see the use of mandatory bind variables (value and humanInput) and optional bind variables. The names and values of bind variables are given, as arguments of the method. You can also provide a map, where the keys are the bind variable names, and the values are the bind variable values. </p>
<p>When you execute the query, an exception is thrown if a mandatory bind variable value is missing.</p>
<p>If an optional bind variable value is missing, then the relevant parameter is not sent to the server. In the above sample, the <i>anotherValueParam</i> is not given. So the <i>anotherValue</i> param is not sent to the server.</p></div>
<div class="section">
<h4><a name="Partial_queries.2Fmutations.2Fsubscriptions"></a><a name="Partial_queriesmutationssubscriptions">Partial queries/mutations/subscriptions</a></h4>
<p>In each query/mutation/subscription object, the plugin also generates <i>Xxxx</i> and <i>XxxxWithBindValues</i> methods, where <i>Xxxx</i> is successively each query/mutation/subscription defined in this query/mutation/subscription object. </p>
<p>These methods allows to directly receive the result in the relevant type:</p>
<div class="source">
<pre>HumanInput input = new HumanInput();
..
[putting some content into input]
..
Human human = queryType.createHuman (
                &quot;(value:&amp;value, anotherValue: ?anotherValue) {id name appearsIn friends {id name}}&quot;,
                // Then we put the list of expected parameters for createHuman
                input,
                // Then the bind variables, by pair of parameters: the bind variable name, then its value
                &quot;value&quot;, &quot;the value&quot;, &quot;humanInput&quot;, input);
</pre></div>
<p>This method generates less code. </p>
<p>But directives can't be added on the query/mutation/subscription level. Of course, they can still be added in the given queries, that is on fields and fragments.</p>
<p>The bind variables works as specified for the Full queries.</p></div></div>
<div class="section">
<h3><a name="How_to_execute_a_GraphQL_query.3F"></a><a name="How_to_execute_a_GraphQL_query">How to execute a GraphQL query?</a></h3>
<p>When in <i>client</i> mode, you can query the server with just one line of code.</p>
<p>For instance :</p>
<div class="source">
<pre>import my.target.package.Human; // my.target.package is the package name defined in the pom
import my.target.package.QueryType; // my.target.package is the package name defined in the pom

...

        QueryType queryType = new QueryType(&quot;http://my.server.com/graphql&quot;);
        Human human = queryType.human(&quot;{id name appearsIn homePlanet friends{name}}&quot;, &quot;180&quot;);
</pre></div>
<p>Where human is a POJO, that you can manipulate as any java object. This POJOs and the QueryType(s) have been generated at build time, thanks to the plugin configured in your pom.</p>
<p>The generated QueryType has also these constructors:</p>
<div class="source">
<pre>    public QueryType(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
</pre></div>
<p>and, with a preconfigured Jersey client instance to support customization of the rest request:</p>
<div class="source">
<pre>    public QueryType(String graphqlEndpoint, Client client, ObjectMapper objectMapper)
</pre></div></div>
<div class="section">
<h3><a name="GraphQL_query_.28and_mutation.29_calls"></a><a name="GraphQL_query_and_mutation_calls">GraphQL query (and mutation) calls</a></h3>
<p>You call query and mutation in the same way: by calling the relevant java method that has been generated at build time.</p>
<p>The Query and the Mutation generated classes have the same name, as defined in the GraphQL schema. They are generated into the package defined in your pom (see above). The standard way is to provide the URL (either http or https) to the constuctor of the Query or Mutation class.</p>
<p>For https server, a second constructor allows you to provide a specific SSLContext and HostnameVerifier. We use it in Integration Test, to allow the client to connect to an https server with a self-signed certificate (as we don't have the money to buy a proper certificate)</p>
<p>Once the Query or/and the Mutation class(es) is/are created, you can call the GraphQL server. Just use the instance, you created, and call the query or mutation method.</p>
<p>Each such method has the same name as in the GraphQL schema. Each such method is generated twice, with two kind of parameters, described just below. It returns the type indicated in the GraphQL schema. The two kind of methods are the direct query (or mutation) and the prepared query (or mutation).</p>
<div class="section">
<h4><a name="Direct_Query_.28or_Mutation.29_call"></a><a name="Direct_Query_or_Mutation_call">Direct Query (or Mutation) call</a></h4>
<p>The signature is of this type:</p>
<div class="source">
<pre>    Yyyy xxx(String queryResponseDef, Pppp param1, Pppp param2..)
</pre></div>
<p>Where:</p>
<ul>
<li>Yyyy is the type, defined in the GraphQL schema as the return type for this Query or Mutation. Yyyy is actually the POJO generated by graphql-java-generator, from the GraphQL Type of the same name.</li>
<li>xxx is the name of the Query or Mutation</li>
<li>queryResponseDef is directly the GraphQL request </li>
<li>param1, param2 (..) are the parameters, as defined in the GraphQL schema</li></ul>
<p>Here is a sample, taken from the StarWars sample project:</p>
<div class="source">
<pre>    List&lt;Board&gt; boards = queryType.boards(&quot;{id name publiclyAvailable topics(since: \&quot;2020-01-15\&quot;){id}}&quot;);
</pre></div>
<p>This is the simplest way to execute a GraphQL query. But:</p>
<ul>
<li>There are some checks at each execution (to check that your parameters are valid). It is more efficient to prepare the request first (see below).</li>
<li>This kind of queries <b>can not manage field parameters that are Input Types (only scalars)</b></li>
<li>It's up to your to format the value for the field parameters</li>
<li>And you'll know if the request is valid only when you execute it </li></ul></div>
<div class="section">
<h4><a name="Prepared_Query_.28or_Mutation.29_call"></a>Prepared Query (or Mutation) call</h4>
<p>In this second <b>and recommanded</b> method, you prepare the response of the query/mutation first. The idea is to build an <i>ObjectResponse</i> once, that you'll reuse for every call of this type to the server. An <i>ObjectResponse</i> is actually the graphql-java-generator object created to match a query string <i>{id name appearsIn homePlanet friends{name}}</i>.</p>
<p>You do this once, typically when the application starts:</p>
<ul>
<li>The graphql-java-generator initializes its stuff only once</li>
<li>You known at startup time that all your requests are valid.
<ul>
<li>Also, when starting an integration test, the requests are prepared ... and checked. </li></ul></li></ul>
<p>There are two ways to prepare the query/mutation response:</p>
<ol style="list-style-type: decimal">
<li>The GraphQL way:</li></ol>
<div class="source">
<pre>(init)
                ObjectResponse boardsAndTopicsResponse = queryType.getBoardsResponseBuilder()
                                .withQueryResponseDef(&quot;{id name publiclyAvailable topics(since:?sinceParam){id}}&quot;).build();
</pre></div>
<p>Note: you can also prefix sinceParam by &amp;, if this parameter is mandatory from a client side point of view:</p>
<div class="source">
<pre>(init)
                ObjectResponse boardsAndTopicsResponse = queryType.getBoardsResponseBuilder()
                                .withQueryResponseDef(&quot;{id name publiclyAvailable topics(since:&amp;sinceParam){id}}&quot;).build();
</pre></div>
<p>Then, later in the code, you can use this prepared query:</p>
<div class="source">
<pre>                // This will set the value sinceValue to the sinceParam field parameter 
                List&lt;Board&gt; boards = queryType.boards(boardsAndTopicsResponse, &quot;sinceParam&quot;, sinceValue);
</pre></div>
<p>If your query has more than one parameter, just add the couples of name and value:</p>
<div class="source">
<pre>                List&lt;Board&gt; boards = queryType.boards(boardsAndTopicsResponse, &quot;sinceParam&quot;, sinceValue, &quot;param2&quot;, value2, &quot;param3&quot;, value3 [...] );
</pre></div>
<ol style="list-style-type: decimal">
<li>The builder way:</li></ol>
<div class="source">
<pre>(init)
                boardsAndTopicsResponse = queryType.getBoardsResponseBuilder().withField(&quot;id&quot;).withField(&quot;name&quot;)
                                .withField(&quot;publiclyAvailable&quot;).withSubObject(new Builder(Board.class, &quot;topics&quot;)
                                                .withInputParameter(InputParameter.newBindParameter(&quot;since&quot;, &quot;sinceParam&quot;, true)).build())
                                .build();
</pre></div>
<p>Here above, the sinceParam is mandatory, as the third parameter for newBindParameter is true. If you want it is not mandatory, from a client point of view, just change true by false when adding the InputParameter.</p>
<p>Then, you can call to the method exactly as in the previous case:</p>
<div class="source">
<pre>                // This will set the value sinceValue to the sinceParam field parameter 
                List&lt;Board&gt; boards = queryType.boards(boardsAndTopicsResponse, &quot;sinceParam&quot;, sinceValue);
                
                //With more than one parameter:
                List&lt;Board&gt; boards = queryType.boards(boardsAndTopicsResponse, &quot;sinceParam&quot;, sinceValue, &quot;param2&quot;, value2, &quot;param3&quot;, value3 [...] );
</pre></div></div></div>
<div class="section">
<h3><a name="Prepare_your_GraphQL_queries">Prepare your GraphQL queries</a></h3>
<p>The <i>ObjectResponse</i> is the heart of the graphql-java-generator, when in client mode. It is responsible for:</p>
<ul>
<li>Defining what fields are expected in the GraphQL server response, for instance <i>{id name appearsIn homePlanet friends{name}}</i></li>
<li>Check the validity of the query string at build time. That is: if the query string is invalid, a GraphQLRequestPreparationException exception is thrown.</li>
<li>(in the near future) mark the queried fields as queried, so that calling a getter on a non-queried field result in an error (instead of &quot;believing&quot; that this value is null). </li></ul></div>
<div class="section">
<h3><a name="Create_an_ObjectResponse_with_a_query_string">Create an ObjectResponse with a query string</a></h3>
<p>To prepare the queries during startup, you can initialize a local variable, like in the given samples, for instance here is an extract of WithQueries, from the StarWars sample. In this sample, the <i>heroFriendsFriendsFriends()</i> method executes the query and returns the GraphQL server response, mapped into the relevant POJO.</p>
<div class="source">
<pre>public class WithQueries implements Queries {

        final QueryType queryType;
        ObjectResponse heroFriendsFriendsFriendsResponse;
...

        public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
                        throws GraphQLRequestPreparationException {
                queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
                heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder()
                                .withQueryResponseDef(&quot;{id appearsIn friends {name friends {friends{id name appearsIn}}}}&quot;).build();
...
        }

        public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
                return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
        }

}
</pre></div></div>
<div class="section">
<h3><a name="Create_an_ObjectResponse_with_an_ObjectResponse_Builder">Create an ObjectResponse with an ObjectResponse Builder</a></h3>
<p>You can also use a Builder to generate the query, by adding field by field, and subobject by subobject, like below. Of course, it's more verbose.</p>
<div class="source">
<pre>public class WithQueries implements Queries {

        final QueryType queryType;
        ObjectResponse heroFriendsFriendsFriendsResponse;
...

        public WithQueries(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier)
                        throws GraphQLRequestPreparationException {
                queryType = new QueryType(graphqlEndpoint, sslContext, hostnameVerifier);
...
                // Equivalent to  &quot;{id appearsIn name friends {name friends {friends{id name appearsIn}}} primaryFunction }&quot;
                ObjectResponse friends3 = ObjectResponse.newSubObjectBuilder(Character.class).withField(&quot;id&quot;).withField(&quot;name&quot;)
                                .withField(&quot;appearsIn&quot;).build();
                ObjectResponse friends2 = ObjectResponse.newSubObjectBuilder(Character.class).withSubObject(&quot;friends&quot;, friends3)
                                .build();
                ObjectResponse friends1 = ObjectResponse.newSubObjectBuilder(Character.class).withField(&quot;name&quot;)
                                .withSubObject(&quot;friends&quot;, friends2).build();
                heroFriendsFriendsFriendsResponse = queryType.getHeroResponseBuilder().withField(&quot;id&quot;).withField(&quot;appearsIn&quot;)
                                .withSubObject(&quot;friends&quot;, friends1).build();
...
        }

        public Character heroFriendsFriendsFriends() throws GraphQLExecutionException {
                return queryType.hero(heroFriendsFriendsFriendsResponse, Episode.NEWHOPE);
        }

}
</pre></div></div>
<div class="section">
<h3><a name="How_to_manager_input_parameters">How to manager input parameters</a></h3>
<p>graphql-java-generator manages two kind of parameters:</p>
<ul>
<li>The query/mutation/subscription input parameters. That is, the parameters for the field of Query type, Mutation type or Subscription type. These input parameters are parsed before the code is generated. In the generated code, there is a method per query, mutation and subscription. This method has, as parameters, the list of input parameters defined in the GraphQL schema, for this query/mutation/subscription. See below for more details.</li>
<li>The input parameters for field in standard GraphQL type. This input parameters are in the GraphQL query, depending on the ObjetResponse you define. So these parameters must be managed by you, when you define the response expected by the server. See below for more details.</li></ul>
<div class="section">
<h4><a name="How_to_use_Query.2FMutation.2FSubscription_input_parameters"></a><a name="How_to_use_QueryMutationSubscription_input_parameters">How to use Query/Mutation/Subscription input parameters</a></h4>
<p>See the sample, here above (prepared queries) and these samples :</p>
<ul>
<li>In the <i>graphql-maven-plugin-samples/graphql-maven-plugin-samples-Forum-client project</i>, in the <i>com.graphql_java_generator.samples.forum.client.graphql.PreparedQueries</i> class,
<ul>
<li>The constructor creates the ObjectResponse objects that will be use latter, for query executions.</li>
<li>The <i>boardsSimple()</i> method calls a query without query parameters: there is no parameter when calling <i>queryType.boards(ObjectResponse)</i> out of the ObjectResponse itself (which defines what returns is expected from the server).</li>
<li>The <i>findTopics(String boardName, List&lt;String&gt; keyword)</i> calls the <i>queryType.findTopics(findTopicIdDateTitleContent, boardName, keyword)</i> method with these parameters: the ObjectResponse, and the two parameters for the GraphQL query. 
<ul>
<li>This <i>queryType.findTopics(..)</i> method is generated by graphql-java-generator. It contains all the query/mutation/subscription parameters as method parameters.</li>
<li>If you don't want to use one of these parameters, <b>just send null as a value</b>, and this parameter will be ignored. Of course, if this parameter is mandatory, this will throw a server-side error.</li>
<li>It would work the same, if it was a GraphQL mutation or a GraphQL subscription, instead of a GraphQL query</li></ul></li></ul></li></ul></div>
<div class="section">
<h4><a name="How_to_use_Field_input_parameters.2C_for_standard_GraphQL_Types"></a><a name="How_to_use_Field_input_parameters_for_standard_GraphQL_Types">How to use Field input parameters, for standard GraphQL Types</a></h4>
<p>See the sample, here above (prepared queries) and these samples :</p>
<ul>
<li>In the graphql-maven-plugin-samples/graphql-maven-plugin-samples-Forum-client project:
<ul>
<li>In the <i>com.graphql_java_generator.samples.forum.client.PreparedQueriesWithFieldInputParametersIT</i> class, all the test methods use the ObjectResponse prepared in the <i>beforeAll()</i> method</li>
<li>Depending on the method, one parameter to three parameters are added to the parameter <i>map</i>:
<ul>
<li><i>since</i> is added in the <i>beforeEach()</i></li>
<li>The other parameters are added, or not, in their respective methods.</li>
<li>If a parameter is not added into the map, it will be ignored during the query build, and not sent to the GraphQL server. Of course, if this input parameter is mandatory, this will throw a server-side error.</li></ul></li></ul></li></ul>
<p>The input parameters can be defined in several ways:</p>
<ul>
<li>For Direct queries, it's up to you to build the query string that is sent to the server. So it's up to you to write the field input parameters in this query string, to escape and format them.
<ul>
<li>You can find such samples in the DirectQueries classes of the various client samples. Especially the Forum one.</li></ul></li>
<li>For queries prepared with a Query String:
<ul>
<li>You defined the input parameters of your query/mutation/subscription, when you create the ObjectResponse object.
<div class="source">
<pre>                // Request preparation
                String queryResponseDef = &quot;{id name publiclyAvailable topics{id date author{id name email type} nbPosts &quot;
                                + &quot;posts(memberId:\&quot;00000000-0000-0000-0000-000000000012\&quot;, memberName: ?memberName, since: &amp;sinceParam) {date author{name email type}}}}&quot;;
                ObjectResponse response = queryType.getBoardsResponseBuilder().withQueryResponseDef(queryResponseDef).build();
...
                // Request execution
                List&lt;Board&gt; boards = queryType.boards(response, &quot;memberName&quot;, &quot;a member Name&quot;, &quot;sinceParam&quot;, &quot;1900/10/24&quot;);
</pre></div></li>
<li>You can see here that you can have three kind of input parameters (here for the posts field of the Topic GraphQL object):
<ul>
<li>memberId is a hard coded value. It's a hard coded value, as the value is given while building the ObjectReponse. The value is stored once in the ObjectResponse, at preparation time. It can not be changed later, at execution time.</li>
<li>memberName is an optional bind parameter. It's optional, as the value is a string, starting with '?'. What's next of the '?' is the bind variable name. Here the bind variable has the same name as the input parameter. Which is Ok.</li>
<li>sinceParam is a mandatory bind parameter. It's mandatory, as the value is a string, starting with '!'. What's next of the '!' is the bind variable name. Here the bind variable has a name that is different from the name as the input parameter. Which is also Ok. Thus, you can have several 'since' (or any other) parameters in your query request, and you can define a specific bind variable for each occurrence, or you the same bind variable for all (in which case, of course, all parameters will receive the same value).</li></ul></li></ul></li></ul>
<p><b>TODO : to be completed, with a sample in this doc</b></p></div></div>
<div class="section">
<h3><a name="Use_a_Spring_Bean">Use a Spring Bean</a></h3>
<p>Instead of create a local variable for your ObjectResponse, another idea is to create a Spring Bean:</p>
<div class="source">
<pre>        @Bean
        ObjectResponse heroResponse(QueryType queryType) {
                return queryType.getHeroResponseBuilder().build();
        }
</pre></div>
<p>Doing this allows you to use this ObjectResponse, later on, in other Spring component(s), with something like this: </p>
<div class="source">
<pre>        @Component
        class YourClass {
        
        @Resource
        ObjectResponse heroResponse;
        
        Character hero = queryType.hero(heroResponse, Episode.NEWHOPE);
        ...
}
</pre></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2020.All rights reserved.      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
